#Stepper Robot lib reference

== Overview ==
This library implements a class that takes care to synchronize the two motors to produce programmed motions. All methods are non-blocking and library works with unipolar or bipolar stepper motors. Advanced features were implemented for vibration reduction, energy saving and protection of control circuits.

=== Features ===
 * Extremely precise movements.
 * Non-blocking methods.
 * Works with bipolar or unipolar motors.
 * Automatic acceleration and deceleration.
 * Allows storing movement commands in a buffer so they run in sequence.
 * Advanced capabilities for vibration control at low speeds.
 * Supports half-step and full-step mode with one or two coils.
 * Uses Timer 1 to control the pulse's timing.
 * Do not need a service function that is often called from the main loop. 

*Note:* This version uses TimerOne? library to control the timer. This library is not included on package but you can download from [http://playground.arduino.cc/Code/Timer1 Timer1 page]. 


== Introduction ==
The library assumes that there are two 4-phase stepping motors installed on differential configuration. It is also assumed that both motors have the same number of steps per revolution. The motors can be unipolar or bipolar. The main class controls both motors maintaining synchrony between them to produce different movements quantified by pulses. Each pulse when sent to coils, make motors spin one step.

All methods are non-blocking. All return immediately and when appropriate, perform the movement in background. The methods never wait the end of the movement to return. The movements are controlled using the Timer 1 Arduino. This gives more accurately for timing pulses and also eliminates the need for a service function that is often called by the main loop.

This version implements the following movement types:
{{{
#define mvAhead    0
#define mvBack     1
#define mvSpinL    2
#define mvSpinR    3
#define mvTurnL    4
#define mvTurnR    5
#define mvBkTurnL  6
#define mvBkTurnR  7
#define mvBrake    8
}}}


== Automatic acceleration ==
A pair of stepper motors can move a relatively heavy robot at a relatively high speed, but that speed can only be achieved gradually. Motors can not initiate the movement at full speed and even if it were possible, would not be desirable because the fixed structures on the robot as sensors, arms, antennas, cameras and other could suffer intense inertial impacts.

The main class implements an automatic control of acceleration and deceleration in all movements performed to enable higher end speed. The parameters for this feature are defined at instance initialization by:
{{{
# define startSpeed      ​​72 // start speed (pulses per second)
# define cruiseSpeed ​​   182 // cruise speed (pulses per second)
# define pulsesToCruise 110 // how many pulses to get cruising
}}}

The motors start movement at the speed indicated by *startSpeed* ​​and gradually accelerates until it reaches cruising speed set by *cruiseSpeed*. The number of pulses that will be used for the acceleration (or deceleration) is informed by *pulsesToCruise*. To stop or change the type of movement the robot is decelerated until it reaches the starting speed. This control is automatic.

== Initialization ==
The library already creates an instance of the main class (rob) but it needs to be initialized in setup() function. Is also required inform which pins will be used for each engine. If necessary you can use the analog pins.
{{{
 rob.init(startSpeed, cruiseSpeed, pulsesToCruise);
 rob.initRightMotor(4,5,6,7);
 rob.initLeftMotor(9,10,11,12);
}}}

== Bufferized commands ==
The library includes a circular buffer capable of storing a large amount of movement commands. Once stored, these commands can be executed in sequence automatically.

== Operating Modes ==
All stepper motor can be operated at least 3 modes : full step with one coil, full step with two coils and half step. The library supports the three modes. There are two attributes in the class that controls the mode of operation: halfStep and turbo. 
halfStep have highest priority and selects between half-step and full-step mode. If the full-step mode is selected, then the turbo attribute selects between full-step with one coil or two. When half-step mode is selected turbo attribute has no effect. The four methods listed below control these two attributes. It is recommended to select the operating mode in setup() function and does not change during operation. Frequent mode changes may impact on the accuracy of navigation. It is important to note that the operation mode of motors have impact in vibration. In half-step mode vibration levels are much lower.
{{{
void halfStepOn();
void halfStepOff();
void turboOn();
void turboOff();
}}}

== Vibration Control ==
Stepper motors have operating characteristics that need to be taken into account during its operation. At low revs, some vibration before it reaches cruising speed, can occur. Eventually, depending on the motor used, battery voltage, the weight of the robot and other factors, certain values ​​of RPM, vibration can be severe enough to disrupt navigation causing deviations in the robot trajectory. To reduce vibration, the library uses two techniques. The first is to make the acceleration and deceleration pass more quickly through the low rpm. So the acceleration is not linear, the robot accelerates (or decelerates) more strongly at low revs and more smoothly at higher speeds.

Second technique uses cutting the supply coils before the end of pulse during the acceleration / deceleration. Normally the coils of motors are fed throughout the duration of the pulse. But in order to reduce the vibration of the power coils can be cut before the end of the pulse and wait for the remaining time with the coils turned off. This technique in addition to greatly decrease the vibration at low revs, also happens to save energy and increase robot autonomy. The tests gave very positive results, so this feature is already enabled by default.

The *setCutPercent()* method informs the initial cut percentage. This percentage is a value between 0 and 1 that indicates the percentage of the pulse before cutting. For example, if the pulse has a duration of 10 milliseconds and percentage reported is 0.75, then the coils will be powered by 75% of the time (7.5 ms) and kept turned off the remaining time (2.5 ms).
{{{
void setCutPercent(float initialCutPercent);
}}}

Cutting coils is only done during the acceleration / deceleration. At cruising speed there is no cut. The value entered by *setCutPercent()* method refers to the initial cutoff value, which is applied when the motors rotate at the start speed. As speed increases, percentage increases until reaching 1.0 (100%) at cruising speed.

The best value for this parameter depends on so many factors that must be calibrated especially for the robot in question and the operation mode of motors (half or full step) experimentally. Very high values ​​(close to 1) are less effective, but very low values ​​can cause the loss of steps. The default value is 0.9.

= Movimentos =
Os movimentos podem ser solicitados de duas maneiras: usando o método move() ou usando o método addMove() em conjunto com o método goNow().

O método move() não usa o buffer circular, o movimento não é armazenado, é executado imediatamente. O método inicia o movimento e retorna. Caso o robô já esteja em movimento, chamadas a esse método são ignoradas e não têm nenhum efeito. Para saber se o robô está em movimento, use o método isMoving().

O método stopNow() aborta o movimento em curso imediatamente. Isso é feito simplesmente interrompendo o fluxo de pulsos, portanto cortando a alimentação das bobinas. Dependendo das condições, isso pode não parar imediatamente o robô, já que existe a inércia do movimento em curso que pode empurrar o robô por mais alguns centímetros.
{{{
boolean move(char movType, int pulses);
boolean isMoving();
void stopNow();
void decelStop();
}}}

O método decelStop() também aborta o movimento em curso, mas faz isso forçando o robô a entrar em desaceleração. O robô para quando atinge a velocidade de partida. A quantidade de pulsos que o robô irá andar até parar efetivamente depende da velocidade em que está se movendo. Se for a velocidade de cruzeiro (máxima) então será necessária a quantidade de pulsos especificada por pulsesToCruize. Se a velocidade for menor, então serão necessários menos pulsos.

= Lista de movimentos =
A outra maneira usa o método addMove(). Este método apenas armazena o movimento no buffer e retorna, o movimento não é iniciado imediatamente. Para iniciar a execução dos movimentos armazenados é preciso chamar o método goNow(). O método goNow() inicia a execução da lista de movimentos e retorna. Os movimentos armazenados no buffer serão executados em sequência até que o buffer fique vazio ou até que seja chamado o método stopAndClear(). Este método chama o método decelStop() para parar o movimento atual e deleta todos os movimentos pendentes no buffer.

É possível adicionar mais movimentos a qualquer momento, mesmo enquanto eles são executados. Os novos movimentos passam a fazer parte da lista de movimentos em execução.
{{{
boolean addMove(int movType, int pulses);
void goNow();
void stopAndClear();
}}}

= Chopper para travar rodas =
Os quatro movimentos do tipo turn exigem que uma das rodas fique parada na mesma posição enquanto a outra se move fazendo um círculo. Para garantir que a roda parada fique realmente parada, as bobinas são ativadas travando a roda na posição em que está. No caso do movimento mvBrake, as duas rodas ficam travadas na mesma posição. Sempre que as rodas estão travadas, a biblioteca utiliza a técnica de chopper para energizar as bobinas. Isso evita que uma bobina fique ligada continuamente por um tempo longo, o que poderia queimar o motor ou a placa controladora. Além de proteger o motor e os circuitos, também economiza energia, já que a bobina não fica ligada o tempo todo.

Abaixo a declaração da classe tal como é vista pelo arquivo principal.
{{{
class StepperRobot{
public:
   // Inicialização
   void init(int startSpeed, int cruizeSpeed, int pulsesToCruizeSpeed);
   void initLeftMotor(int mPin_1, int mPin_2, int mPin_3, int mPin_4);
   void initRightMotor(int mPin_1, int mPin_2, int mPin_3, int mPin_4);
 
   // Movimento
   boolean move(char movType, int pulses);
   boolean isMoving();
   void decelStop();
   void stopNow();
 
   // Lista de movimentos
   boolean addMove(int movType, int pulses);
   void goNow();
   void stopAndClear();
 
   // Configuração
   void turboOn();
   void turboOff();
   void halfStepOn();
   void halfStepOff();
   void setCutPercent(float initialCutPercent)
};
 
StepperRobot rob;
}}}

= Programa exemplo =
{{{
#include <TimerOne.h>
#include <StepperRobot.h>
 
#define stepsPerRevolution  48  // Passos por volta. Assume-se que os dois motores são iguais
#define startSpeed          72  // velocidade de partida em pulsos por segundo
#define cruizeSpeed        182  // velocidade de cruzeiro em pulsos por segundo
#define pulsesToCruize     110  // quantos pulsos para chegar em cruzeiro
 
#define statusLed           13  // led onboard para status
 
void setup() {
  // Led de status
  pinMode(statusLed, OUTPUT);
 
  rob.init(startSpeed, cruizeSpeed, pulsesToCruize);
  rob.initRightMotor(2,3,4,5);
  rob.initLeftMotor(A3,A2,A1,A0);  // funciona com os pinos analógicos.
 
  rob.halfStepOff();
  rob.turboOn();
 
  digitalWrite(statusLed, true);
  delay(1500); // Vai achar este delay muito conveniente
  digitalWrite(statusLed, false);
}
 
// pulsos para volta completa
#define turnPulses 320
#define spinPulses (turnPulses/2)
 
// dica importante: A quantidade de pulsos para dar uma volta completa
// nos dois movimentos acima depende (entre outras coisas) da distancia
// entre as rodas. Pequenas diferenças na distancia já provocam erros
// de navegação bem significativos. Se for possível, ajuste a distancia
// entre as rodas para que a quantidade de pulsos para dar uma volta
// no movimento turn assuma um valor com o maior número de divisores
// possível. No mínimo que seja um número par. Se for possível que seja
// divisível por 4 ou 8 ou 16, etc, melhor ainda. Isso permite maior
// precisão para obter frações de volta.
 
void loop() {
  // led de status com batida de coração
  // não funciona se tiver muitos delays no código
  unsigned long ms= millis();
  digitalWrite( statusLed, (ms >> 8) & (ms >> 6) & 1);
 
  if(!rob.isMoving())
  {
    delay(100);  // espera baixar a poeira
 
    // Armazena a sequencia de movimentos
    rob.addMove(mvAhead, stepsPerRevolution*5);
    rob.addMove(mvSpinL, spinPulses*2);
    rob.addMove(mvSpinR, spinPulses*2);
    rob.addMove(mvBack, stepsPerRevolution*5);
    rob.addMove(mvSpinR, spinPulses/4);
    rob.addMove(mvTurnL, turnPulses /2);
    rob.addMove(mvTurnR, turnPulses/2);
    rob.addMove(mvTurnL, turnPulses);
    rob.addMove(mvBkTurnR, turnPulses/2);
    rob.addMove(mvBkTurnL, turnPulses/2);
    rob.addMove(mvSpinR, 3 * spinPulses / 4);
    rob.addMove(mvBrake, startSpeed*5);
 
    // Agora começa a executar os movimentos armazenados.
    rob.goNow();
  }
}

}}}